# @license BSD-3 https://opensource.org/licenses/BSD-3-Clause
# Copyright (c) 2023, Institute of Automatic Control - RWTH Aachen University
# All rights reserved. 

using Base.Filesystem
using DataFrames
using FileIO
using ImageCore
using ImageIO
using JSON
using SciGL

dataset_path(dataset_name) = joinpath(pwd(), "datasets", dataset_name)
datasubset_path(dataset_name, subset_name="test") = joinpath(dataset_path(dataset_name), subset_name)

"""
    scene_paths(dataset_name, [subset_name="test"])
Returns a vector of the full paths to the scene directories of the datasets subset.
"""
scene_paths(dataset_name="lm", subset_name="test") = readdir(datasubset_path(dataset_name, subset_name); join=true)

"""
    lpad_bop(number)
Pads the number with zeros from the left for a total length of six digits.
`pad_bop(42) = 000042`
"""
lpad_bop(number) = lpad(number, 6, "0")

"""
    image_dataframe(scene_path, modality="depth")
Load the image information as a DataFrame with the columns `img_id, img_path, img_size` with `img_size=(width, height)`
"""
function image_dataframe(scene_path, modality="depth")
    dir = joinpath(scene_path, modality)
    img_paths = readdir(dir; join=true)
    img_ids = @. parse(Int, img_paths |> splitext |> first |> splitpath |> last)
    img_sizes = map(img_paths) do img_path
        # ImageIO loads transposed
        img = img_path |> load |> transpose
        size(img)
    end
    DataFrame(img_id=img_ids, img_path=img_paths, img_size=img_sizes)
end

"""
    camera_dataframe(scene_path, img_df)
Load the camera information as a DataFrame with the columns `img_id, camera, depth_scale`.
`img_df` is the DataFrame generated by `image_dataframe` for the same `scene_path`.
"""
function camera_dataframe(scene_path, img_df)
    img_sizes = Dict(img_df.img_id .=> img_df.img_size)
    json_cams = JSON.parsefile(joinpath(scene_path, "scene_camera.json"))
    img_ids = parse.(Int, keys(json_cams))
    df = DataFrame(img_id=Int[], camera=CvCamera[], depth_scale=Float32[])
    for img_id in img_ids
        width, height = img_sizes[img_id]
        json_cam = json_cams[string(img_id)]
        cam_K = json_cam["cam_K"] .|> Float32
        cv_cam = CvCamera(width, height, cam_K[1], cam_K[5], cam_K[3], cam_K[6]; s=cam_K[4])
        scale = json_cam["depth_scale"] .|> Float32
        push!(df, (img_id, cv_cam, scale))
    end
    df
end

"""
    gt_dataframe(scene_path)
Load the ground truth information for each object and image as a DataFrame with the columns `img_id, obj_id, cam_R_m2c, cam_t_m2c`.
"""
function gt_dataframe(scene_path)
    gt_json = JSON.parsefile(joinpath(scene_path, "scene_gt.json"))
    df = DataFrame(img_id=Int[], obj_id=Int[], cam_R_m2c=QuatRotation[], cam_t_m2c=Translation[])
    for (img_id, value) in gt_json
        img_id = parse(Int, img_id)
        for gt in value
            obj_id = gt["obj_id"]
            # Saved row-wise, Julia is column major
            cam_R_m2c = reshape(gt["cam_R_m2c"], 3, 3)' |> RotMatrix3 |> QuatRotation
            cam_t_m2c = Float32.(1e-3 * gt["cam_t_m2c"]) |> Translation
            push!(df, (img_id, obj_id, cam_R_m2c, cam_t_m2c))
        end
    end
    df
end

# ImageIO loads image transposed by default
load_depth_image(path, depth_scale) = Float32(1e-3 * depth_scale) .* (path |> load |> channelview |> rawview |> transpose)
"""
    load_depth_image(image_df, img_id)
Load the depth image as a Matrix{Float32} of size (width, height) where each pixel is the depth in meters.
"""
function load_depth_image(df::DataFrame, img_id::Integer)
    row = findfirst(x -> x == img_id, df.img_id)
    load_depth_image(df.img_path[row], df.depth_scale[row])
end

# Per scene
first_scene_path = scene_paths("itodd", "val") |> first

# Per image
img_df = image_dataframe(first_scene_path, "depth")
cam_df = camera_dataframe(first_scene_path, img_df)
img_cam_df = innerjoin(img_df, cam_df; on=:img_id)

# load the image
depth_img = load_depth_image(img_cam_df, first(img_df.img_id))

Gray.(depth_img)
Gray.(depth_img ./ maximum(depth_img))

# Per evaluation
gt_df = gt_dataframe(first_scene_path)
df = leftjoin(gt_df, img_cam_df, on=:img_id)

# TODO Goal: load an element from scene_gt.json and render the gt pose on top of the image.

# TODO init context with mesh model and camera for each config in the df
"""
    object_dataframe(dataset_name)
# TODO
"""
function object_dataframe(dataset_name)
    path = dataset_path(dataset_name)
    json = JSON.parsefile(joinpath(path, "models_eval", "models_info.json"))
    df = DataFrame(obj_id=Int[], diameter=Float32[], mesh=Mesh[])
    for (obj_id, data) in json
        obj_id = parse(Int, obj_id)
        diameter = Float32(1e-3 .* data["diameter"])
        filename = "obj_" * lpad_bop(obj_id) * ".ply"
        mesh_file = joinpath(path, "models_eval", filename)
        mesh = Scale(Float32(1e-3))(load(mesh_file))
        # TODO It makes more sense to keep the mesh in memory so replace mesh_file & scale in Parameters.jl
        push!(df, (obj_id, diameter, mesh))
    end
    df
end

obj_df = object_dataframe("itodd")
new_df = leftjoin(df, obj_df, on=:obj_id)